<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JVM on Howie</title>
        <link>https://yanghaoyu.xyz/tags/jvm/</link>
        <description>Recent content in JVM on Howie</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 18 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yanghaoyu.xyz/tags/jvm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JVM - 类的加载和双亲委派</title>
        <link>https://yanghaoyu.xyz/b/jvm-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</link>
        <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yanghaoyu.xyz/b/jvm-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</guid>
        <description>&lt;img src="https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/blog-hero-jvm-loadclass.png" alt="Featured image of post JVM - 类的加载和双亲委派" /&gt;&lt;h2 id=&#34;从哪里加载&#34;&gt;从哪里加载?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从本地磁盘加载 (class 文件, jar 包, zip 包)&lt;/li&gt;
&lt;li&gt;通过网络资源加载&lt;/li&gt;
&lt;li&gt;从数据库中提取 class 文件&lt;/li&gt;
&lt;li&gt;java 文件动态编译为 class 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一个类的生命周期&#34;&gt;一个类的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;加载&lt;/code&gt; -&amp;gt; &lt;code&gt;验证&lt;/code&gt; -&amp;gt; &lt;code&gt;准备&lt;/code&gt; -&amp;gt; &lt;code&gt;解析&lt;/code&gt; -&amp;gt; &lt;code&gt;初始化&lt;/code&gt;
这里的几个阶段是按顺序开始(而不保证是按顺序进行的)
在这五个阶段中, &lt;code&gt;加载&lt;/code&gt; &lt;code&gt;验证&lt;/code&gt; &lt;code&gt; 准备&lt;/code&gt; &lt;code&gt;初始化&lt;/code&gt;这四个阶段顺序是确定的, 而解析阶段则不一定,它在某些情况下可以在初始化阶段之后开始,这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。&lt;/p&gt;
&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;
&lt;p&gt;在 java 中,一个 class 都是 &lt;code&gt;ClassLoader&lt;/code&gt; 加载的, 加载时类加载的第一个阶段&lt;/p&gt;
&lt;p&gt;在这个阶段, JVM 把类读入内存
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/p&gt;
&lt;p&gt;加载阶段完成后, 虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,
而且在 Java 堆中也创建一个 &lt;code&gt;java.lang.Class&lt;/code&gt; 类的对象, 这样便可以通过该对象访问方法区中的这些数据&lt;/p&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;p&gt;验证是为了确保 Class 文件是否是合法的,主要检验以下 4 个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件格式：是否以 &lt;code&gt;0xCAFEBABE&lt;/code&gt; 开头,版本号是否正确, 常量池中的常量是否有不被支持的类型&lt;/li&gt;
&lt;li&gt;元数据：对字节码描述的信息进行语义分析, 以保证其描述的信息符合 Java 语言规范的要求&lt;/li&gt;
&lt;li&gt;字节码：通过数据流和控制流分析, 确保程序语义是合法的&lt;/li&gt;
&lt;li&gt;符号引用：确保后续的解析阶段能正确执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;
&lt;p&gt;准备阶段会为类变量分配内存并设置类变量初始值的阶段, 这些内存都将在方法区中分配
值得注意的是: 在这里分配的都是默认的 0 值, 例如: &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, 并不是程序员所指定的值, 如果使用 final 修饰,那么才会在这里初始化为程序员指定的值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public static int i = 1&lt;/code&gt; 将被分配为 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static final int j = 1&lt;/code&gt; 将被分配为 1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解析&#34;&gt;解析&lt;/h3&gt;
&lt;p&gt;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行&lt;/p&gt;
&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;
&lt;p&gt;初始化,正式为类变量设置初始值, 也就是程序员所指定的值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static int i = 1&lt;/code&gt; 将在此时被初始化为 1&lt;/p&gt;
&lt;h4 id=&#34;初始化步骤&#34;&gt;初始化步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;假如这个类还没有被加载和连接, 则程序先加载并连接该类&lt;/li&gt;
&lt;li&gt;假如该类的直接父类还没有被初始化, 则先初始化其直接父类&lt;/li&gt;
&lt;li&gt;假如类中有初始化语句, 则系统依次执行这些初始化语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;初始化时机&#34;&gt;初始化时机&lt;/h4&gt;
&lt;p&gt;只有当对类的主动使用的时候才会导致类的初始化, 主要包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;new Instance&lt;/li&gt;
&lt;li&gt;访问某个类或接口的静态变量, 或者对该静态变量赋值&lt;/li&gt;
&lt;li&gt;调用类的静态方法&lt;/li&gt;
&lt;li&gt;反射使用到此类&lt;/li&gt;
&lt;li&gt;初始化某个类的子类, 则其父类也会被初始化&lt;/li&gt;
&lt;li&gt;Java 虚拟机启动时被标明为启动类的类, 直接使用 &lt;code&gt;java&lt;/code&gt; 命令来运行某个主类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之, 在第一次使用到时初始化&lt;/p&gt;
&lt;h3 id=&#34;双亲委派机制&#34;&gt;双亲委派机制&lt;/h3&gt;
&lt;p&gt;在 JDK 中内置了 3 种 ClassLoader&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;BootstrapClassLoader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ExtClassLoader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/jvm-classloader.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;class-loader.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这三种类加载器主要的职责并不相同&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BootstrapClassLoader&lt;/code&gt;, 主要负责加载 JDK 中的类( &lt;code&gt;%JDK_HOME%\jre\lib&lt;/code&gt;下的类 ), 或被 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 参数指定的路径中的, 启动类加载器是无法被 Java 程序直接引用的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ExtClassLoader&lt;/code&gt;,主要负责加载 JDK 中内部实现的扩展类(&lt;code&gt;%JDK_HOME%\jre\lib\ext&lt;/code&gt;下的类),该加载器由 &lt;code&gt;sun.misc.Launcher$ExtClassLoader &lt;/code&gt;实现, 开发者可以直接使用扩展类加载器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AppClassLoader&lt;/code&gt;, 主要负责程序中的类文件的加载, 该类加载器由 &lt;code&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt; 来实现, 开发者可以直接使用该类加载器, 并且它是默认的类加载器。&lt;/p&gt;
&lt;p&gt;加载器在加载过程中, 先把类交由父类加载器进行加载, 父类加载器没找到才自身加载, 这就是双亲委派机制&lt;/p&gt;
&lt;p&gt;具体来讲就是以下规则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 &lt;code&gt;AppClassLoader&lt;/code&gt; 加载类时, 它并不会先自己加载这个类, 而是先把类加载请求委派给父加载器 &lt;code&gt;ExtClassLoader&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;ExtClassLoader&lt;/code&gt; 加载类时, 它也不会首先自己去加载这个类, 而是把类加载请求委派给父加载器 &lt;code&gt;BootStrapClassLoader&lt;/code&gt; 去完成&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;BootStrapClassLoader&lt;/code&gt; 加载失败会使用 &lt;code&gt;ExtClassLoader&lt;/code&gt; 来尝试加载&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;ExtClassLoader&lt;/code&gt; 加载失败, 则会使用 &lt;code&gt;AppClassLoader&lt;/code&gt; 来加载&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;AppClassLoader&lt;/code&gt; 加载失败, 就报出异常 &lt;code&gt;ClassNotFoundException&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;源码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getClassLoadingLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;// First, check if the class has already been loaded
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 首先 判断是否被加载过
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findLoadedClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nanoTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// 让父加载器加载
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;loadClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;c1&#34;&gt;// 如果父加载器不存在
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;c1&#34;&gt;// 就检查是否是由启动类加载器加载的类
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ClassNotFoundException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// ClassNotFoundException thrown if class not found
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// from the non-null parent class loader
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// If still not found, then invoke findClass in order
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// to find the class.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nanoTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;// this is the defining class loader; record the stats
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getParentDelegationTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getFindClassTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addElapsedTimeFrom&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;PerfCounter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getFindClasses&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;resolveClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findBootstrapClassOrNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;checkName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;findBootstrapClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;双亲委派最主要的好处就是: 防止了 JVM 中出现多份相同的字节码, 同时也保证了 JDK 基础类库的安全(自己定义的&lt;code&gt;java.lang.Object&lt;/code&gt;并不会被加载)&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM - 垃圾收集器</title>
        <link>https://yanghaoyu.xyz/b/jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</link>
        <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yanghaoyu.xyz/b/jvm-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</guid>
        <description>&lt;img src="https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/gc.png" alt="Featured image of post JVM - 垃圾收集器" /&gt;&lt;p&gt;GC (Garbage Collectors), 垃圾收集器. 是对 GC 算法的具体实现, 在 JVM 主要有 7 中收集器,&lt;code&gt;Serial&lt;/code&gt;,&lt;code&gt;Serial Old&lt;/code&gt;, &lt;code&gt;ParNew&lt;/code&gt;, &lt;code&gt;Parallel Scavenge&lt;/code&gt;,&lt;code&gt;Parallel Old&lt;/code&gt;,&lt;code&gt;CMS&lt;/code&gt;,&lt;code&gt;G1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/gc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;gc.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;serial&#34;&gt;&lt;code&gt;Serial&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;Serial 是一个采用&lt;code&gt;复制算法&lt;/code&gt;的单线程垃圾收集器, 这意味着 Serial 进行工作时,会暂停所有的用户正常工作的线程(Stop the World),效率高,&lt;/p&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;主要用于&lt;code&gt;Young Gen&lt;/code&gt;的回收, 是 JVM 运行在 Client 模式下的默认新生代回收器&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/serial-gc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;serial.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;parnew&#34;&gt;&lt;code&gt;ParNew&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-1&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ParNew&lt;/code&gt; 实际上就是 &lt;code&gt;Serial&lt;/code&gt; 的多线程版本&lt;/p&gt;
&lt;h3 id=&#34;应用场景-1&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;是 JVM 运行在 Server 模式下的首选的新生代回收器,&lt;code&gt;ParNew&lt;/code&gt;能与&lt;code&gt;CMS&lt;/code&gt;配合工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/par-new.gc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;parnew-gc.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;parallel-scavenge&#34;&gt;&lt;code&gt;Parallel Scavenge&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-2&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Parallel Scavenge&lt;/code&gt;是一个新生代收集器, 它也是采用的复制算法, 是并行的多线程收集器。这个收集器主要关注吞吐量,
&lt;code&gt;吞吐量 = 运行用户代码时间 / (运行用户代码时间 + gc时间)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;GC 自适应的调节策略：
Parallel Scavenge 收集器有一个参数&lt;code&gt;-XX:+UseAdaptiveSizePolicy&lt;/code&gt;. 当这个参数打开之后, 就不需要手工指定新生代的大小(&lt;code&gt;-Xmn&lt;/code&gt;), Eden 与 Survivor 区的比例(&lt;code&gt;-XX:SurvivorRatio&lt;/code&gt;)、晋升老年代对象年龄(&lt;code&gt;-XX:PretenureSizeThreshold&lt;/code&gt;)等细节参数了, 虚拟机会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量, 这种调节方式称为 GC 自适应的调节策略（GC Ergonomics）。&lt;/p&gt;
&lt;h3 id=&#34;应用场景-2&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;停顿时间越短就越适合需要与用户交互的程序, 而高吞吐量则可以高效率地利用 CPU 时间, 主要适合在后台运算而不需要太多交互的任务, &lt;code&gt;Parallel Scavenge&lt;/code&gt; 收集器也经常被称为“吞吐量优先”收集器.&lt;/p&gt;
&lt;h2 id=&#34;serial-old&#34;&gt;&lt;code&gt;Serial Old&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-3&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;Serial Old 是 Serial 收集器的老年代版本, 他同样是个单线程收集器, 使用“标记整理”算法。&lt;/p&gt;
&lt;h3 id=&#34;应用场景-3&#34;&gt;应用场景&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;这个收集器的主要意义是给 Client 模式下的虚拟机使用&lt;/li&gt;
&lt;li&gt;在 Server 模式下, 可以作为&lt;code&gt;CMS&lt;/code&gt;的后备方案&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;parallel-old&#34;&gt;&lt;code&gt;Parallel Old&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-4&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 使用多线程和“标记-整理”算法。&lt;/p&gt;
&lt;h3 id=&#34;应用场景-4&#34;&gt;应用场景&lt;/h3&gt;
&lt;h2 id=&#34;cms&#34;&gt;&lt;code&gt;CMS&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-5&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器, &lt;code&gt;并发收集、低停顿&lt;/code&gt;是它的特点&lt;/p&gt;
&lt;p&gt;CMS 工作过程主要分为以下几步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;初始标记 (initial mark)&lt;/code&gt;&lt;br&gt;
初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象, 速度快, 需要 STW。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;并发标记 (concurrent mark)&lt;/code&gt;&lt;br&gt;
并发标记阶段就是进行 GC Roots Tracing 的过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;重新标记 (remark)&lt;/code&gt;&lt;br&gt;
重新标记阶段是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录, 这个阶段的停顿时间一般会比初始标记阶段稍长一些, 但远比并发标记的时间短, 需要 STW。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;并发清除 (concurrent sweep)&lt;/code&gt;&lt;br&gt;
并发清除阶段会清除对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/cms-gc.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;cms.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;CMS 默认启动的回收线程数是（CPU 数量+3）/ 4, 当 CPU 在 4 个以上时, 并发回收时垃圾收集线程不少于 25% 的 CPU 资源, 并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个时, CMS 对用户程序的影响就可能很大。&lt;/p&gt;
&lt;p&gt;CMS 收集器无法处理&lt;code&gt;浮动垃圾&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;浮动垃圾&lt;/code&gt; : 由于 CMS 并发清理阶段用户线程还在运行着, 伴随程序运行自然就还会有新的垃圾不断产生(因此需要预留有足够的内存空间给用户线程使用,如果预留的内存无法满足程序需要, 就会出现一次&lt;code&gt;Concurrent Mode Failure&lt;/code&gt;使用&lt;code&gt;Serial Old&lt;/code&gt;对老年代进行回收), 这一部分垃圾出现在标记过程之后, CMS 无法在当次收集中处理掉它们, 只好留待下一次 GC 时再清理掉。这一部分垃圾就称为&lt;code&gt;浮动垃圾&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CMS 收集器会产生大量空间碎片&lt;/p&gt;
&lt;h2 id=&#34;g1&#34;&gt;&lt;code&gt;G1&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&#34;特性-6&#34;&gt;特性&lt;/h3&gt;
&lt;p&gt;G1 是基于“标记-整理”算法实现的收集器, 引入分区的思路, 弱化了分代的概念, 合理利用垃圾收集各个周期的资源, 解决了其他收集器甚至 CMS 的众多缺陷。&lt;/p&gt;
&lt;p&gt;它没有新生代和老年代的概念, 而是将堆划分为一块块独立的 &lt;code&gt;Region&lt;/code&gt;. 当进行垃圾收集时, G1 会先估计每个 Region 中垃圾的数量, 每次都从垃圾回收价值最大的 Region 开始回收, 因此可以获得最大的回收效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/g1-region.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;gc-region&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了防止遍历整个堆空间, 每个 Region 都有一个&lt;code&gt;Remembered Set&lt;/code&gt;用于记录该 Region 中所有对象引用的对象所在的区域,进行可达性分析时, 只要在 GC Roots 中再加上 &lt;code&gt;Remembered Set&lt;/code&gt; 即可防止对整个堆内存进行遍历。&lt;/p&gt;
&lt;p&gt;如果不计算维护 &lt;code&gt;Remembered Set&lt;/code&gt; 的操作, G1 收集器的工作过程分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;初始标记&lt;/code&gt;
&lt;code&gt;STW&lt;/code&gt;, 仅使用一条初始标记线程对所有与 &lt;code&gt;GC Roots&lt;/code&gt; 直接关联的对象进行标记。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;并发标记&lt;/code&gt;
使用一条标记线程与用户线程并发执行。此过程进行可达性分析, 速度很慢。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最终标记&lt;/code&gt;
&lt;code&gt;STW&lt;/code&gt;, 使用多条标记线程并发执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;筛选回收&lt;/code&gt;
回收废弃对象, 此时也要 &lt;code&gt;STW&lt;/code&gt;, 并使用多条筛选回收线程并发执行。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>JVM -  happens-before 规则</title>
        <link>https://yanghaoyu.xyz/b/jvm-happens-before-%E8%A7%84%E5%88%99/</link>
        <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yanghaoyu.xyz/b/jvm-happens-before-%E8%A7%84%E5%88%99/</guid>
        <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把一个变量表示为一个线程独占, 作用于主内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把一个变量从锁定状态释放, 作用于主内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把主内存的变量传输到工作内存, 作用于主内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;load&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 &lt;code&gt;read&lt;/code&gt; 操作的得到的变量放入工作内存的变量副本,作用于工作内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;use&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把一个变量的值传给执行引擎,作用于工作内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;assign&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把一个从执行引擎接受到的值赋给工作内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;store&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把一个工作内存的一个变量传送到主内存, 作用于工作内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把&lt;code&gt;store&lt;/code&gt;得到的变量写入主内存, 作用于主内存的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;JMM 还规定了如下规则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;/&lt;code&gt;load&lt;/code&gt;,&lt;code&gt;store&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;必须成对出现&lt;/li&gt;
&lt;li&gt;变量在工作内存中改变了必须写回主内存, 不允许丢弃&lt;code&gt;assign&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不允许一个线程无原因地把数据写回主内存&lt;/li&gt;
&lt;li&gt;在工作内存中不允许使用未初始化的变量, 即在&lt;code&gt;use&lt;/code&gt;,&lt;code&gt;store&lt;/code&gt;之前必须&lt;code&gt;assign&lt;/code&gt;或&lt;code&gt;load&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个变量只能被一个线程&lt;code&gt;lock&lt;/code&gt;,同一个线程可以多次&lt;code&gt;lock&lt;/code&gt;同一个变量 (可重入)&lt;/li&gt;
&lt;li&gt;&lt;i style=&#34;color:red;font-weight:700&#34;&gt;如果对一个变量执行 &lt;code&gt;lock&lt;/code&gt;,那么工作内存要清空这个变量的值, 在执行引擎之前使用之前, 需要重新 &lt;code&gt;load&lt;/code&gt;或&lt;code&gt;assign&lt;/code&gt; (这也是为什么加锁后线程安全的原因)&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;对一个变量没有&lt;code&gt;lock&lt;/code&gt;,就不允许对它&lt;code&gt;unlock&lt;/code&gt;,也不允许&lt;code&gt;unlock&lt;/code&gt;被其他线程 lock 住的变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unlock&lt;/code&gt;之前要执行&lt;code&gt;store&lt;/code&gt;,&lt;code&gt;write&lt;/code&gt;,把工作内存的变量写回主内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;happens-before&#34;&gt;&lt;code&gt;happens-before&lt;/code&gt;&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;程序次序规则&lt;/td&gt;
&lt;td&gt;一个线程内,写在前面的操作先于写在后面的操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;管程锁定规则&lt;/td&gt;
&lt;td&gt;对于同一个锁, &lt;code&gt;unlock&lt;/code&gt;必须先于&lt;code&gt;lock&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;volatile 规则&lt;/td&gt;
&lt;td&gt;对一个 volatile 变量,写操作先于读操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程启动规则&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Thread#start&lt;/code&gt;先于此线程的所有动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程终止规则&lt;/td&gt;
&lt;td&gt;线程的所有操作先于对此线程的终止检测&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;线程中断规则&lt;/td&gt;
&lt;td&gt;线程的 interrupt 方法的调用先于中断线程检测到中断事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对象终结规则&lt;/td&gt;
&lt;td&gt;一个对象的构造函数的结束先于&lt;code&gt;finalize&lt;/code&gt;方法的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传递性&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A happens-before B&lt;/code&gt;, &lt;code&gt;B happens-before C&lt;/code&gt; =&amp;gt; &lt;code&gt;A happens-before C&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        <item>
        <title>JVM - synchronized 实现原理</title>
        <link>https://yanghaoyu.xyz/b/jvm-synchronized-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yanghaoyu.xyz/b/jvm-synchronized-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;img src="https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/object-monitor.png" alt="Featured image of post JVM - synchronized 实现原理" /&gt;&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/object-monitor.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;对象头monitor&#34;&gt;&lt;code&gt;对象头&lt;/code&gt;,&lt;code&gt;Monitor&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在 JVM 中，对象在内存中的布局分为三块区域：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象头&lt;/li&gt;
&lt;li&gt;实例数据&lt;/li&gt;
&lt;li&gt;对齐填充&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/object-header.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;object.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中对象头是实现 synchronized 的基础,对象头分为两部分 &lt;code&gt;Mark Word&lt;/code&gt;, &lt;code&gt;Klass Pointer&lt;/code&gt;, &lt;code&gt;Mark Word&lt;/code&gt; 存储对象的 hashCode、锁信息或分代年龄或 GC 标志等信息,&lt;code&gt;Klass Pointer&lt;/code&gt;指向该类的 Class 对象&lt;/p&gt;
&lt;p&gt;下表是 Mark Word 的具体信息(64 位)&lt;/p&gt;
&lt;h2 id=&#34;synchronized-的锁升级&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt; 的锁升级&lt;/h2&gt;
&lt;p&gt;在 JDK6 之后, synchronized 底层的锁有了 4 种状态 &lt;code&gt;无锁&lt;/code&gt;,&lt;code&gt;偏向锁&lt;/code&gt;,&lt;code&gt;轻量级锁&lt;/code&gt;,&lt;code&gt;重量级锁&lt;/code&gt;,每一种状态在 &lt;code&gt;Mark Word&lt;/code&gt; 中均有记录&lt;/p&gt;
&lt;p&gt;每一个锁都对应一个 monitor 对象(在 HotSpot 中由 ObjectMonitor 实现的)。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ObjectMonitor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_header&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_count&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 计数器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;_waiters&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_recursions&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_object&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_owner&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_WaitSet&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_WaitSetLock&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_Responsible&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_succ&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_cxq&lt;/span&gt;          &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;FreeNext&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_EntryList&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_SpinFreq&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;_SpinClock&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;OwnerIsThread&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_WaitSet&lt;/code&gt; :储存处于 wait 状态的线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_EntryList&lt;/code&gt;:保存用于储存等待锁的线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_owner&lt;/code&gt; :指向持有 ObjectMonitor 对象的线程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当多个线程尝试进入临界区时, 首先会进入&lt;code&gt;_EntryList&lt;/code&gt; 集合,
当线程获取到对象的 monitor 后, 把 monitor 中的 &lt;code&gt;_owner&lt;/code&gt; 指向当前线程, 同时计数器 count++
当线程调用 &lt;code&gt;wait&lt;/code&gt; 方法, owner 变量恢复为 &lt;code&gt;NULL&lt;/code&gt;,count&amp;ndash;, 表明当前线程释放 &lt;code&gt;monitor&lt;/code&gt;,随后该线程进入 &lt;code&gt;_WaitSet&lt;/code&gt; 集合中等待
如果当前线程执行完毕也会释放 monitor&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/object-monitor.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;synchronized-的锁膨胀&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt; 的锁膨胀&lt;/h2&gt;
&lt;p&gt;synchronized 底层的锁有了 4 种状态 &lt;code&gt;无锁&lt;/code&gt;-&amp;gt;&lt;code&gt;偏向锁&lt;/code&gt;-&amp;gt;&lt;code&gt;轻量级锁&lt;/code&gt;-&amp;gt;&lt;code&gt;重量级锁&lt;/code&gt;,膨胀方向不可逆&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/lock.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;lock&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;偏向锁&#34;&gt;&lt;code&gt;偏向锁&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果一个线程获得了锁，那么锁就进入偏向模式，此时 &lt;code&gt;Mark Word&lt;/code&gt; 的结构也就变为偏向锁结构，
当该线程再次请求锁时,
只需要检查 &lt;code&gt;Mark Word&lt;/code&gt; 的锁标记位为偏向锁和当前线程 ID 是否等于 &lt;code&gt;Mark Word&lt;/code&gt; 的 &lt;code&gt;ThreadID&lt;/code&gt;
如果相等, 则当前线程获取成功,如果获取不成功, 表明这不是原来的进程, 则升级为&lt;code&gt;轻量级锁&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁&#34;&gt;&lt;code&gt;轻量级锁&lt;/code&gt;&lt;/h3&gt;
&lt;h4 id=&#34;加锁&#34;&gt;加锁&lt;/h4&gt;
&lt;p&gt;当锁未被锁定,虚拟机现在线程的栈帧中创建&lt;code&gt;Displaced Lock Record&lt;/code&gt;,用于储存锁目前线程的&lt;code&gt;Mark Word&lt;/code&gt;, 然后虚拟机尝试使用&lt;code&gt;CAS&lt;/code&gt;把锁对象的&lt;code&gt;Mark Word&lt;/code&gt;指向&lt;code&gt;Displaced Lock Record&lt;/code&gt;,然后把锁标示位改为 00,这就表示该线程拥有了这个锁. 如果 CAS 失败,那么虚拟机会检测对象的&lt;code&gt;Mark Word&lt;/code&gt;是否指向当前线程的栈帧,如果没有则表明锁已经被其他线程抢占了(如果有两条以上的线程抢锁的话,膨胀为重量级锁)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/displaced-lock-record.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Displaced-Lock-Record.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;解锁&#34;&gt;解锁&lt;/h4&gt;
&lt;p&gt;使用 CAS 把&lt;code&gt;Mark Word&lt;/code&gt;替换回来,如果替换失败的话,表明其他线程在抢锁,需要在释放锁的同时唤醒被阻塞的线程&lt;/p&gt;
&lt;h3 id=&#34;重量级锁&#34;&gt;&lt;code&gt;重量级锁&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;重量级锁&lt;/code&gt;是由轻量级锁升级而来，当同一时间有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。&lt;/p&gt;
&lt;h3 id=&#34;锁消除&#34;&gt;&lt;code&gt;锁消除&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;锁消除&lt;/code&gt;是虚拟机另外一种锁的优化，这种优化更彻底，在 JIT 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁&lt;/p&gt;
&lt;h3 id=&#34;锁粗化&#34;&gt;&lt;code&gt;锁粗化&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;锁粗化&lt;/code&gt;是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM - GC算法</title>
        <link>https://yanghaoyu.xyz/b/jvm-gc%E7%AE%97%E6%B3%95/</link>
        <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yanghaoyu.xyz/b/jvm-gc%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h2 id=&#34;回收哪些空间&#34;&gt;回收哪些空间?&lt;/h2&gt;
&lt;p&gt;JVM 要求回收&lt;code&gt;堆&lt;/code&gt;,&lt;code&gt;方法区&lt;/code&gt;中的垃圾&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在堆中回收&lt;code&gt;没有指针指向的对象&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于方法区, JVM 确实说过可以不要求虚拟机在永久代实现垃圾收集,
对于永久代的回收主要是回收&lt;code&gt;废弃常量&lt;/code&gt;和&lt;code&gt;无用的类&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;废弃常量&lt;/code&gt;
在字符串常量池中存在 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;,但是没有任何指针指向这个字面量,那么这个&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;就是废弃常量,在 gc 时会被清理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;无用的类&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该类所以实例已被回收&lt;/li&gt;
&lt;li&gt;这个类的类对象没有被引用&lt;/li&gt;
&lt;li&gt;该类的 ClassLoader 已被回收&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果某个满足上述上条件, 则这个类判定为&lt;code&gt;无用的类&lt;/code&gt;, 可以被回收(不是一定被回收)
可以使用 &lt;code&gt;-Xnoclassgc&lt;/code&gt;这个虚拟机选项 进行控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自从&lt;code&gt;方法区&lt;/code&gt;的实现由&lt;code&gt;永久代&lt;/code&gt;变为&lt;code&gt;元空间&lt;/code&gt;, 方法区的溢出的情况大大减少&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何判断哪些对象需要被回收&#34;&gt;如何判断哪些对象需要被回收?&lt;/h2&gt;
&lt;h3 id=&#34;1-引用计数算法&#34;&gt;1. 引用计数算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给对象添加一个引用计数器,如果被指针引用起来,则计数器+1,当指针不在引用该对象时,计数器-1,当计数器==0,则释放该对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引用计数法的实现简单,效率高,但是 JVM 并未使用该算法,主要原因是这种算法很难解决&lt;code&gt;循环引用&lt;/code&gt;的问题&lt;/p&gt;
&lt;p&gt;如下图, a 引用了 b,b 也引用了 a,但是没有其他指向 a 的指针,也没有其他指向 b 的指针,这两个对象都是无法使用的,理应删除,但是由于计数器不为 0,这两个对象依旧不会被释放
&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/recycle-ref.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ref&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;2可达性分析&#34;&gt;2.可达性分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这种算法就是把所有对象构成一张图,对该图进行遍历,判断结点是否可达,如果可达,表明该对象有可能被使用,则不释放,如果不可达,则释放该对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JVM 规定从 GC Root 开始遍历,GC Root 主要包括以下几种对象:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机栈(栈帧的本地变量表)中引用的对象&lt;/li&gt;
&lt;li&gt;方法区(永久代/元空间)中静态属性引用的对象&lt;/li&gt;
&lt;li&gt;方法区(永久代/元空间)中常量引用的对象&lt;/li&gt;
&lt;li&gt;本地方法栈 JNI 引用到的对象 (native 方法引用的对象)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/gc-root.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;可达性分析&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;怎样回收对象&#34;&gt;怎样回收对象?&lt;/h2&gt;
&lt;h3 id=&#34;1-标记清除算法-mark-and-sweep&#34;&gt;1. 标记清除算法 (Mark-And-Sweep)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这个算法分为两个阶段
标记阶段: 首先把需要回收的对象标记出来
清除阶段: 对带标记的对象进行清理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/mark-and-swap.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;标记清除算法&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这种算法会产生大量的内存碎片,使得内存利用率降低,造成在生成新对象时查找下一个空闲块花费大量时间,效率降低&lt;/p&gt;
&lt;h3 id=&#34;2-复制算法-copying&#34;&gt;2. 复制算法 (Copying)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这种算法解决了&lt;code&gt;标记清除算法&lt;/code&gt;产生内存碎片的问题,它把内存分成 2 块,每次使用其中一块,每次进行清理时,把存活的对象复制到另一块,再把当前使用的块一次性全部清理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/copying.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;复制算法&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这种算法的弊端主要在于可使用的内存降低了 50%,并且对于大对象的复制是非常耗时的,效率降低&lt;/p&gt;
&lt;h3 id=&#34;3标记整理算法-mark-and-compact&#34;&gt;3.标记整理算法 (Mark-And-Compact)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这种算法主要思想为:在清理阶段需要把存活的对象全部向一端移动,然后直接回收掉边界以外的内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://howieyoung.oss-cn-chengdu.aliyuncs.com/blog/img/mark-and-compact.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;标记整理算法&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-分代收集算法-generation-collection&#34;&gt;4. 分代收集算法 (Generation Collection)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这种算法综合使用了以上几种算法, 是主流的 GC 算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JVM 把堆区划分为两个年代,根据年代的不同而采用不同的算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;新生代 (Young Gen)&lt;/code&gt; 这个区域对象存活率较低,大批对象死亡,采用复制算法清理这个区域的对象,占 1/3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;老年代(Old Gen)&lt;/code&gt; 这个区域对象存活率高,采用标记整理算法,占 2/3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 在新生代使用复制算法,它把新生代分为两块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;伊甸园(Eden)&lt;/code&gt; 占新生代 8/10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;幸存者(Survivor)&lt;/code&gt; 占新生代 2/10&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中幸存者又被分为两块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;From&lt;/code&gt; 占幸存者 1/2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;To&lt;/code&gt; 占幸存者 1/2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 Eden 区满时,会除法 Minor GC,对新生代使用复制算法,把 Eden 和目前正在使用的 Survivor 区的垃圾进行标记,然后把可达的对象复制到另一个 Survivor 区域,并回收垃圾。随着新对象的生产，Eden 再次满时会使用相同的算法，对象会在 From 和 To 之间来回移动，如果这个移动超过 15 次(可以通过&lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt; 设置)，该对象会被放进老年代。&lt;/p&gt;
&lt;p&gt;JVM 存在&lt;code&gt;内存担保机制&lt;/code&gt;,即大对象直接进入老年代,不会经过新生代&lt;/p&gt;
&lt;p&gt;当老年代的对象越来越多,直到老年代内存放不下了,会触发 Full GC 对新生代、老生代、方法区进行回收&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
